<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Attack Detection</title>
    <style>
        :root {
            color-scheme: light dark;
            font-family: "Inter", "Segoe UI", system-ui, sans-serif;
            --bg: #0f172a;
            --bg-card: rgba(15, 23, 42, 0.92);
            --border: rgba(148, 163, 184, 0.25);
            --accent: #38bdf8;
            --accent-dark: #0ea5e9;
            --text: #e2e8f0;
            --text-soft: #cbd5f5;
            --success: #34d399;
            --danger: #f87171;
            --warning: #facc15;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            background: radial-gradient(circle at 10% 20%, rgba(56, 189, 248, 0.15), transparent 65%),
                        radial-gradient(circle at 90% 10%, rgba(129, 140, 248, 0.12), transparent 60%),
                        linear-gradient(160deg, #020617 0%, #0b1120 50%, #111827 100%);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 32px 18px 64px;
        }

        header {
            text-align: center;
            max-width: 760px;
            margin-bottom: 32px;
        }

        header h1 {
            font-size: clamp(2rem, 5vw, 3.25rem);
            letter-spacing: 0.05em;
            margin: 0 0 12px;
        }

        header p {
            margin: 0;
            line-height: 1.6;
            color: var(--text-soft);
        }

        main {
            width: min(1100px, 100%);
            display: grid;
            gap: 22px;
        }

        section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 18px;
            padding: 26px 26px 30px;
            box-shadow: 0 22px 60px rgba(15, 23, 42, 0.45);
        }

        section h2 {
            margin: 0 0 14px;
            font-size: 1.35rem;
            letter-spacing: 0.04em;
            text-transform: uppercase;
        }

        .card-description {
            margin: 0 0 22px;
            color: var(--text-soft);
            line-height: 1.55;
            font-size: 0.98rem;
        }

        .upload-area {
            position: relative;
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 32px;
            text-align: center;
            transition: border-color 0.25s ease, background 0.25s ease;
            background: rgba(30, 41, 59, 0.4);
            display: block;
            cursor: pointer;
        }

        .upload-area.dragover {
            border-color: var(--accent);
            background: rgba(56, 189, 248, 0.12);
        }

        .upload-area strong {
            display: block;
            font-size: 1.1rem;
            margin-bottom: 8px;
        }

        .upload-area p {
            margin: 0;
            color: var(--text-soft);
            font-size: 0.95rem;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        button, .ghost-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border: none;
            border-radius: 999px;
            padding: 0.8rem 1.8rem;
            font-weight: 600;
            letter-spacing: 0.03em;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            font-size: 0.98rem;
        }

        button {
            background: var(--accent);
            color: #020617;
            box-shadow: 0 12px 22px rgba(14, 165, 233, 0.2);
        }

        button:hover:not(:disabled) {
            transform: translateY(-1px);
            background: var(--accent-dark);
            box-shadow: 0 16px 28px rgba(14, 165, 233, 0.28);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
        }

        .ghost-button {
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
        }

        .ghost-button:hover:not(:disabled) {
            border-color: var(--accent);
            color: var(--accent);
        }

        .status-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 18px;
        }

        .status-chip {
            border-radius: 999px;
            padding: 0.4rem 1.1rem;
            background: rgba(148, 163, 184, 0.12);
            font-size: 0.9rem;
        }

        .status-chip.success { background: rgba(52, 211, 153, 0.18); color: var(--success); }
        .status-chip.warning { background: rgba(250, 204, 21, 0.18); color: var(--warning); }
        .status-chip.danger { background: rgba(248, 113, 113, 0.18); color: var(--danger); }

        .results-grid {
            display: grid;
            gap: 16px;
            margin-top: 20px;
        }

        .result-card {
            padding: 18px;
            border-radius: 14px;
            border: 1px solid var(--border);
            background: rgba(30, 41, 59, 0.55);
        }

        .result-card h3 {
            margin: 0 0 10px;
            letter-spacing: 0.03em;
        }

        .metric-row {
            display: flex;
            flex-wrap: wrap;
            gap: 14px;
            font-size: 0.95rem;
        }

        .metric {
            background: rgba(148, 163, 184, 0.14);
            padding: 0.35rem 0.9rem;
            border-radius: 999px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 14px;
            font-size: 0.92rem;
        }

        th, td {
            border: 1px solid rgba(148, 163, 184, 0.25);
            padding: 6px 10px;
            text-align: center;
        }

        th {
            background: rgba(15, 23, 42, 0.75);
            font-weight: 600;
        }

        .prediction-form {
            display: grid;
            gap: 14px;
        }

        .prediction-form label {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.93rem;
            color: var(--text-soft);
        }

        #feature-fields {
            display: grid;
            gap: 12px;
            max-height: 420px;
            overflow-y: auto;
            padding-right: 6px;
        }

        #feature-fields::-webkit-scrollbar {
            width: 6px;
        }

        #feature-fields::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.35);
            border-radius: 999px;
        }

        .feature-field {
            padding: 12px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.18);
        }

        .feature-name {
            font-weight: 600;
            color: var(--text);
        }

        .feature-note {
            font-size: 0.8rem;
            color: var(--text-soft);
        }

        .prediction-form input,
        .prediction-form select,
        .prediction-form textarea {
            background: rgba(15, 23, 42, 0.78);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px 12px;
            color: var(--text);
            font-size: 0.95rem;
        }

        .prediction-result {
            margin-top: 16px;
            padding: 16px;
            border-radius: 14px;
            font-size: 1.05rem;
            font-weight: 600;
        }

        .prediction-result.safe {
            background: rgba(52, 211, 153, 0.18);
            color: var(--success);
        }

        .prediction-result.attack {
            background: rgba(248, 113, 113, 0.18);
            color: var(--danger);
        }

        .manual-controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: flex-end;
            align-items: center;
        }

        code {
            font-family: "Fira Code", "SFMono-Regular", Menlo, monospace;
            background: rgba(148, 163, 184, 0.16);
            padding: 2px 6px;
            border-radius: 6px;
        }

        .small-print {
            font-size: 0.85rem;
            color: var(--text-soft);
            margin-top: 18px;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            body { padding: 22px 14px 48px; }
            section { padding: 22px 20px 26px; }
            .metric-row { flex-direction: column; align-items: flex-start; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Network Attack Detection Lab</h1>
        <p>
            Upload the CDD intrusion dataset, train the Random Forest, SVM, and Neural Network models with the
            built-in preprocessing pipeline, and submit manual feature vectors to simulate real-time threat scoring.
        </p>
    </header>

    <main>
        <section id="upload-section">
            <h2>1 Â· Upload Dataset</h2>
            <p class="card-description">
                Supply a CSV file that mirrors the NSL-KDD / CDD feature layout. The server strips duplicates,
                standardises columns, and records class distribution before training.
            </p>
            <input type="file" id="file-input" accept=".csv" class="sr-only">
            <label class="upload-area" id="dropzone" for="file-input" tabindex="0">
                <strong>Drag a CSV here or click to browse</strong>
                <p id="upload-hint">No file selected</p>
            </label>
            <div class="status-bar" id="upload-status"></div>
        </section>

        <section id="train-section">
            <h2>2 Â· Train Models</h2>
            <p class="card-description">
                Once a dataset is uploaded, launch training to fit the Random Forest, SVM, and MLP classifiers with
                SMOTE balancing, scaling, and encoded categorical features. Results include accuracy, confusion
                matrices, and class frequency diagnostics.
            </p>
            <button id="train-btn" disabled>Train Models</button>
            <div class="status-bar" id="train-status"></div>
            <div class="results-grid" id="results-grid"></div>
        </section>

        <section id="predict-section">
            <h2>3 Â· Manual Prediction</h2>
            <p class="card-description">
                After training, populate each feature and choose an estimator to classify a single network event. Use
                the feature list generated from your dataset; leave categorical values as their original labels.
            </p>
            <form class="prediction-form" id="prediction-form">
                <label>
                    Model
                    <select id="model-select" name="model">
                        <option value="random_forest">Random Forest</option>
                        <option value="svm">Support Vector Machine</option>
                        <option value="neural_network">Neural Network</option>
                    </select>
                </label>
                <div id="feature-fields"></div>
                <div class="manual-controls">
                    <button type="button" class="ghost-button" id="prefill-btn" disabled>Use example values</button>
                    <button type="submit" id="predict-btn" disabled>Detect Attack</button>
                </div>
            </form>
            <div id="prediction-output"></div>
            <p class="small-print" id="feature-hint">
                Train the models to populate the feature inputs automatically. Fields accept either numeric values or
                raw categorical labels (the backend reuses the dataset encoders).
            </p>
        </section>
    </main>

    <script>
        const uploadStatus = document.getElementById('upload-status');
        const trainStatus = document.getElementById('train-status');
        const resultsGrid = document.getElementById('results-grid');
        const predictionForm = document.getElementById('prediction-form');
        const predictBtn = document.getElementById('predict-btn');
        const predictionOutput = document.getElementById('prediction-output');
        const featureFields = document.getElementById('feature-fields');
        const modelSelect = document.getElementById('model-select');
        const trainButton = document.getElementById('train-btn');
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('file-input');
        const uploadHint = document.getElementById('upload-hint');
        const prefillBtn = document.getElementById('prefill-btn');
        const featureHint = document.getElementById('feature-hint');

        const state = {
            datasetInfo: null,
            training: null,
            features: [],
            featureMetadata: {},
        };

        updateFeatureHint([]);

        function setUploadStatus(message, type = 'info') {
            uploadStatus.innerHTML = '';
            const chip = document.createElement('span');
            chip.className = 'status-chip ' + (type === 'success' ? 'success' : type === 'error' ? 'danger' : 'warning');
            chip.textContent = message;
            uploadStatus.appendChild(chip);
        }

        function setTrainStatus(message, type = 'info') {
            trainStatus.innerHTML = '';
            const chip = document.createElement('span');
            chip.className = 'status-chip ' + (type === 'success' ? 'success' : type === 'error' ? 'danger' : 'warning');
            chip.textContent = message;
            trainStatus.appendChild(chip);
        }

        function percent(value) {
            if (typeof value !== 'number' || Number.isNaN(value)) return 'â';
            return `${(value * 100).toFixed(2)}%`;
        }

        function renderResults(results, distribution) {
            resultsGrid.innerHTML = '';
            const summaryTable = document.createElement('table');
            summaryTable.innerHTML = `
                <thead>
                    <tr>
                        <th>Model</th>
                        <th>Test Accuracy</th>
                        <th>Train Accuracy</th>
                    </tr>
                </thead>
                <tbody>
                    ${Object.entries(results).map(([name, stats]) => `
                        <tr>
                            <td>${formatModelName(name)}</td>
                            <td>${percent(stats.accuracy)}</td>
                            <td>${percent(stats.train_accuracy)}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            resultsGrid.appendChild(summaryTable);

            Object.entries(results).forEach(([name, stats]) => {
                const card = document.createElement('article');
                card.className = 'result-card';
                card.innerHTML = `
                    <h3>${formatModelName(name)}</h3>
                    <div class="metric-row">
                        <span class="metric">Accuracy: ${percent(stats.accuracy)}</span>
                        <span class="metric">Train Accuracy: ${percent(stats.train_accuracy)}</span>
                        ${(() => {
                            const cv = stats.cross_val_accuracy || {};
                            if (typeof cv.mean !== 'number') return '';
                            const stdText = typeof cv.std === 'number' ? `${(cv.std * 100).toFixed(2)}%` : 'â';
                            return `<span class="metric">CV Mean: ${percent(cv.mean)} Â± ${stdText}</span>`;
                        })()
                            : ''}
                    </div>
                `;

                if (stats.confusion_matrix) {
                    const table = document.createElement('table');
                    table.innerHTML = `
                        <thead>
                            <tr>
                                <th colspan="${stats.confusion_matrix.length}">Confusion Matrix</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${stats.confusion_matrix.map(row => `
                                <tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>
                            `).join('')}
                        </tbody>
                    `;
                    card.appendChild(table);
                }

                if (stats.classification_report) {
                    const report = document.createElement('pre');
                    const lines = Object.entries(stats.classification_report)
                        .filter(([label]) => !['accuracy', 'macro avg', 'weighted avg'].includes(label) || typeof stats.classification_report[label] === 'object')
                        .map(([label, metrics]) => {
                            if (typeof metrics !== 'object') return null;
                            const precision = (metrics.precision * 100).toFixed(2);
                            const recall = (metrics.recall * 100).toFixed(2);
                            const f1 = (metrics['f1-score'] * 100).toFixed(2);
                            return `${label.padEnd(12)}  P:${precision}%  R:${recall}%  F1:${f1}%`;
                        })
                        .filter(Boolean)
                        .join('\n');
                    report.textContent = `Precision / Recall / F1\n${lines}`;
                    card.appendChild(report);
                }

                resultsGrid.appendChild(card);
            });

            if (distribution) {
                const distCard = document.createElement('article');
                distCard.className = 'result-card';
                distCard.innerHTML = '<h3>Class Distribution</h3>';
                const table = document.createElement('table');
                table.innerHTML = `
                    <thead><tr><th>Label</th><th>Samples</th></tr></thead>
                    <tbody>
                        ${Object.entries(distribution).map(([label, count]) => `
                            <tr><td>${label}</td><td>${count}</td></tr>
                        `).join('')}
                    </tbody>
                `;
                distCard.appendChild(table);
                resultsGrid.appendChild(distCard);
            }
        }

        function formatModelName(key) {
            switch (key) {
                case 'random_forest': return 'Random Forest';
                case 'svm': return 'Support Vector Machine';
                case 'neural_network': return 'Neural Network';
                default: return key;
            }
        }

        function updateModelOptions(modelKeys) {
            if (!Array.isArray(modelKeys) || !modelKeys.length) {
                return;
            }

            const previousSelection = modelSelect.value;
            modelSelect.innerHTML = '';

            modelKeys.forEach((key) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = formatModelName(key);
                modelSelect.appendChild(option);
            });

            if (modelKeys.includes(previousSelection)) {
                modelSelect.value = previousSelection;
            } else {
                modelSelect.value = modelKeys[0];
            }
        }

        function buildFeatureInputs(features) {
            featureFields.innerHTML = '';
            if (!Array.isArray(features) || !features.length) {
                predictBtn.disabled = true;
                if (prefillBtn) prefillBtn.disabled = true;
                updateFeatureHint([]);
                return;
            }

            const hasExampleValues = features.some((feature) => {
                const info = metadata?.[feature];
                return info && info.example !== null && info.example !== undefined && `${info.example}`.trim() !== '';
            });

            features.forEach((feature, index) => {
                const info = metadata?.[feature] || {};
                const wrapper = document.createElement('label');
                wrapper.className = 'feature-field';

                const name = document.createElement('span');
                name.className = 'feature-name';
                name.textContent = feature;
                wrapper.appendChild(name);

                const input = document.createElement('input');
                input.name = feature;
                input.required = true;

                let noteText = '';

                if (info.type === 'numeric') {
                    input.type = 'number';
                    input.step = 'any';
                    const descriptors = [];
                    if (typeof info.min === 'number' && typeof info.max === 'number') {
                        descriptors.push(`range ${info.min} â ${info.max}`);
                    }
                    if (typeof info.mean === 'number') {
                        descriptors.push(`mean ${info.mean.toFixed(2)}`);
                    }
                    input.placeholder = descriptors.length
                        ? `Enter value (${descriptors.join(', ')})`
                        : 'Enter numeric value';
                    noteText = descriptors.length
                        ? `Numeric Â· ${descriptors.join(' Â· ')}`
                        : 'Numeric feature';
                } else if (info.type === 'categorical') {
                    input.type = 'text';
                    const categories = Array.isArray(info.categories) ? info.categories.filter(Boolean) : [];
                    if (categories.length) {
                        const safeId = `categories-${feature.replace(/[^a-zA-Z0-9_-]/g, '-')}-${index}`;
                        input.setAttribute('list', safeId);
                        input.placeholder = `e.g. ${categories[0]}`;
                        const datalist = document.createElement('datalist');
                        datalist.id = safeId;
                        categories.forEach((category) => {
                            const option = document.createElement('option');
                            option.value = category;
                            datalist.appendChild(option);
                        });
                        wrapper.appendChild(datalist);
                    } else {
                        input.placeholder = 'Enter category';
                    }
                    const cardinality = typeof info.cardinality === 'number' && info.cardinality > 0
                        ? `${info.cardinality} unique` : 'categorical';
                    noteText = `Categorical Â· ${cardinality}`;
                } else {
                    input.type = 'text';
                    input.placeholder = 'Enter value';
                }

                wrapper.appendChild(input);

                if (noteText) {
                    const note = document.createElement('span');
                    note.className = 'feature-note';
                    note.textContent = noteText;
                    wrapper.appendChild(note);
                }

                featureFields.appendChild(wrapper);
            });

            predictBtn.disabled = false;
            if (prefillBtn) {
                prefillBtn.disabled = !hasExampleValues;
                prefillBtn.title = hasExampleValues
                    ? 'Populate the inputs with an example row from the dataset'
                    : 'Example values unavailable for this dataset';
            }
            updateFeatureHint(features, metadata);
        }

        function updateFeatureHint(features, metadata = {}) {
            if (!featureHint) return;
            if (!Array.isArray(features) || !features.length) {
                featureHint.textContent = 'Train the models to populate the feature inputs automatically. Fields accept either numeric values or raw categorical labels (the backend reuses the dataset encoders).';
                return;
            }

            const numericCount = features.filter((feature) => metadata?.[feature]?.type === 'numeric').length;
            const categoricalCount = features.filter((feature) => metadata?.[feature]?.type === 'categorical').length;
            const summaryParts = [];
            if (numericCount) summaryParts.push(`${numericCount} numeric`);
            if (categoricalCount) summaryParts.push(`${categoricalCount} categorical`);

            let summary = summaryParts.join(', ');
            if (!summary) summary = 'mixed types';

            featureHint.textContent = `Provide values for ${features.length} features (${summary}). Use raw labels for categorical fields and decimal numbers where required.`;
            if (prefillBtn && !prefillBtn.disabled) {
                featureHint.textContent += ' Click âUse example valuesâ to load a known record for quick testing.';
            }
        }

        function prefillExampleValues() {
            if (!Array.isArray(state.features) || !state.features.length) return false;

            let filled = false;
            state.features.forEach((feature) => {
                const input = predictionForm.elements[feature];
                const info = state.featureMetadata?.[feature] || {};
                if (!input || info.example === null || info.example === undefined) return;
                input.value = info.example;
                filled = true;
            });

            return filled;
        }

        async function bootstrapManualPrediction() {
            try {
                const response = await fetch('/feature-metadata');
                if (!response.ok) return;
                const data = await response.json();
                if (!Array.isArray(data.feature_columns) || !data.feature_columns.length) return;
                state.features = data.feature_columns;
                state.featureMetadata = data.feature_metadata || {};
                buildFeatureInputs(state.features, state.featureMetadata);
            } catch (error) {
                console.debug('Feature metadata unavailable on load', error);
            }
        }

        async function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            setUploadStatus('Uploading datasetâ¦');
            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData,
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Upload failed');
                state.datasetInfo = data;
                uploadHint.textContent = `${data.filename} Â· ${data.rows} rows Ã ${data.columns} columns`;
                setUploadStatus('Dataset ready. Proceed to training.', 'success');
                trainButton.disabled = false;
            } catch (error) {
                console.error(error);
                setUploadStatus(error.message, 'error');
                trainButton.disabled = true;
            }
        }

        async function trainModels() {
            setTrainStatus('Training modelsâ¦');
            trainButton.disabled = true;
            resultsGrid.innerHTML = '';

            try {
                const response = await fetch('/train', {
                    method: 'POST',
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Training failed');

                state.training = data;
                state.features = data.feature_columns || [];
                state.featureMetadata = data.feature_metadata || {};

                updateModelOptions(Object.keys(data.results || {}));
                setTrainStatus(data.message || 'Training complete.', 'success');
                renderResults(data.results, data.class_distribution);
                buildFeatureInputs(state.features, state.featureMetadata);
                predictionOutput.innerHTML = '';
            } catch (error) {
                console.error(error);
                setTrainStatus(error.message, 'error');
                trainButton.disabled = false;
            }
        }

        async function submitPrediction(event) {
            event.preventDefault();
            if (!state.features.length) return;

            predictBtn.disabled = true;
            predictionOutput.innerHTML = '';

            const features = {};
            state.features.forEach((feature) => {
                const rawValue = predictionForm.elements[feature]?.value ?? '';
                const value = typeof rawValue === 'string' ? rawValue.trim() : rawValue;
                if (value === '') {
                    features[feature] = '';
                    return;
                }

                const info = state.featureMetadata?.[feature];
                if (info?.type === 'numeric') {
                    const numeric = Number(value);
                    features[feature] = Number.isFinite(numeric) ? numeric : value;
                } else {
                    features[feature] = value;
                }
            });

            const payload = {
                model: modelSelect.value,
                features,
            };

            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Prediction failed');

                const resultDiv = document.createElement('div');
                resultDiv.className = 'prediction-result ' + (data.is_attack ? 'attack' : 'safe');
                const confidenceText = typeof data.confidence === 'number'
                    ? `${Math.round(data.confidence * 100)}% confidence`
                    : 'confidence unavailable';
                resultDiv.textContent = data.is_attack
                    ? `â ï¸ Attack detected: ${data.prediction} (${confidenceText})`
                    : `â Normal traffic (${confidenceText})`;
                predictionOutput.appendChild(resultDiv);
            } catch (error) {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'prediction-result attack';
                resultDiv.textContent = error.message;
                predictionOutput.appendChild(resultDiv);
            } finally {
                predictBtn.disabled = false;
            }
        }

        async function bootstrapManualPrediction() {
            try {
                const response = await fetch('/status');
                if (!response.ok) return;

                const data = await response.json();
                if (Array.isArray(data.available_models) && data.available_models.length) {
                    updateModelOptions(data.available_models);
                }
                if (Array.isArray(data.feature_columns) && data.feature_columns.length) {
                    state.features = data.feature_columns;
                    buildFeatureInputs(state.features);
                }
            } catch (error) {
                console.warn('Unable to pre-load manual prediction inputs:', error);
            }
        }

        // Event wiring
        bootstrapManualPrediction();

        if (prefillBtn) {
            prefillBtn.addEventListener('click', () => {
                const filled = prefillExampleValues();
                if (filled) {
                    if (featureHint) {
                        featureHint.textContent = 'Example values inserted from the dataset. Adjust any field before detecting.';
                        setTimeout(() => updateFeatureHint(state.features, state.featureMetadata), 4500);
                    }
                } else {
                    prefillBtn.disabled = true;
                    updateFeatureHint(state.features, state.featureMetadata);
                }
            });
        }

        dropzone.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                fileInput.click();
            }
        });
        const activateDragState = (event) => {
            event.preventDefault();
            dropzone.classList.add('dragover');
        };
        dropzone.addEventListener('dragenter', activateDragState);
        dropzone.addEventListener('dragover', activateDragState);
        dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
        dropzone.addEventListener('drop', (event) => {
            event.preventDefault();
            dropzone.classList.remove('dragover');
            const file = event.dataTransfer?.files?.[0] ?? null;
            if (file) {
                uploadHint.textContent = file.name;
                uploadFile(file);
                fileInput.value = '';
            }
        });

        fileInput.addEventListener('change', () => {
            const file = fileInput.files[0];
            if (file) {
                uploadHint.textContent = file.name;
                uploadFile(file);
                fileInput.value = '';
            }
        });

        trainButton.addEventListener('click', trainModels);
        predictionForm.addEventListener('submit', submitPrediction);
        bootstrapManualPrediction();
    </script>
</body>
</html>
